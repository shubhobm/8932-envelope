View(case0902)
names(case0902)
plot(case0902[,2:5])
m1 = lm(Brain ~ Body+Gestation+log(Litter), data=case0902)
summary(m1)
anova(m1)
plot(m1)
leverages = hat(model.matrix(m1)); plot(leverages)
stud.res = rstudent(m1); plot(stud.res); abline(h=0)
CooksD = cooks.distance(m1); plot(CooksD)
(outlier.pt = case0902[3,])
new.data = case0902[-3,]
m2 = update(m1, data=new.data)
summary(m2)
plot(m2)
par(mfrow=c(2,2))
plot(m1)
par(mfrow=c(1,1))
par(mfrow=c(2,2))
plot(m2)
par(mfrow=c(1,1))
(more.outliers = new.data[c(25,48,53),])
(more.outliers = case0902[c(25,48,53),])
new.data1 = case0902[-c(3,25,48,53),]
m3 = update(m2, data=new.data1)
par(mfrow=c(2,2))
plot(m3)
par(mfrow=c(1,1))
m = lm(log(Brain) ~ log(Body)+log(Gestation)+log(Litter), data=case0902)
summary(m)
par(mfrow=c(2,2))
plot(m)
par(mfrow=c(1,1))
View(case0902)
plot(case0902[,2:5])
summary(m1)
anova(m1)
par(mfrow=c(2,2))
plot(m1)
par(mfrow=c(1,1))
leverages = hat(model.matrix(m1)); plot(leverages)
stud.res = rstudent(m1); plot(stud.res); abline(h=0)
CooksD = cooks.distance(m1); plot(CooksD)
(outlier.pt = case0902[3,])
new.data = case0902[-3,]
m2 = update(m1, data=new.data)
summary(m2)
par(mfrow=c(2,2))
plot(m2)
par(mfrow=c(1,1))
par(mfrow=c(2,2))
plot(m1)
par(mfrow=c(1,1))
(more.outliers = case0902[c(25,48,53),])
new.data1 = case0902[-c(3,25,48,53),]
m3 = update(m2, data=new.data1)
summary(m3)
par(mfrow=c(2,2))
plot(m3)
par(mfrow=c(1,1))
plot(case0902[,2:5])
m = lm(log(Brain) ~ log(Body)+log(Gestation)+log(Litter), data=case0902)
summary(m)
par(mfrow=c(2,2))
plot(m)
par(mfrow=c(1,1))
library(VineCopula)
###### required for parallel computing
library(parallel)
library(doSNOW)
set.seed(006); N = 100
theta.range=seq(0,.99,.01)
dfs=c(20:25); mat=matrix(rep(0,6*length(dfs)), ncol=6)
for(i in 1:length(dfs)){
df = dfs[i]
## Simulates max depth copula estimators for all values in theta.range
loopfun = function(theta){
library(VineCopula)
maxdeps = rep(0,1000)
# Generate 1000 samples of size 100 each
for(i in 1:1000){
# Generate sample from t copula
U = BiCopSim(N, family=2, par=theta, par2=df)
u = U[,1]; v = U[,2]
est = BiCopEst(u, v, family=2, method='mle')
interval = c(0,.99)
# interval search algorithm
iterating=TRUE; iter=1; maxit=10
while(iterating){
theta.list = seq(interval[1], interval[2], length.out=10)
dep.list = rep(0,10)
for(j in 1:10){
del.loglik = BiCopDeriv(u,v,family=2,par=theta.list[j], par2=df, deriv="par") /
BiCopPDF(u,v,family=2,par=theta.list[j], par2=df)
dep.list[j] =(min(sum(del.loglik>0), sum(del.loglik<0)) + sum(del.loglik==0))/N
}
# stopping criteria
maxdep = max(na.omit(dep.list))
if(maxdep==0.5 || iter==maxit) iterating = FALSE
# otherwise determine new interval
else{
max.index = which(dep.list==maxdep)
if(length(max.index)==1){
lm = ifelse(max.index==1, interval[1], theta.list[max.index-1])
rm = ifelse(max.index==10, interval[2], theta.list[max.index+1])
}
else{
m1 = min(max.index); m2 = max(max.index)
lm = ifelse(m1==1, interval[1], theta.list[m1-1])
rm = ifelse(m2==10, interval[2], theta.list[m2+1])
}
interval = c(lm,rm)
iter=iter+1
}
}
maxdeps[i] = theta.list[which.max(dep.list)]
}
return(list(theta, mean(maxdeps), sd(maxdeps)))
}
dep.summary = matrix(rep(0,3*length(theta.range)), ncol=3)
cl <- makeCluster(detectCores())
registerDoSNOW(cl)
system.time(dep.summary <- foreach(theta = theta.range) %dopar% loopfun(theta))
dep.summary = matrix(unlist(dep.summary), ncol=3, byrow=T)
stopCluster(cl)
# plot(dep.summary[,2]~theta.range, xlim=c(0,1),ylim=c(0,1), type="p", pch=19, cex=1.2,
#      main=paste("Simulated maximum t-copula (df=",df,") depth estimators"),
#      xlab="Real parameter", ylab="Parameter with maxim um depth")
# for(i in 1:10){
#   segments(dep.summary[i,1],dep.summary[i,2]-dep.summary[i,3],
#            dep.summary[i,1],dep.summary[i,2]+dep.summary[i,3], lwd=2)
# }
# abline(0,1, lty=2)
# Fit cubic regression model
th = dep.summary[,1]; bth = dep.summary[,2]
summary(m <- lm(th ~ bth+I(bth^2)+I(bth^3)))
mat[i,] = c(df, m$coef, dep.summary[1,2])
}
mat
m
summary(m)
plot(dep.summary[,2]~theta.range, xlim=c(0,1),ylim=c(0,1), type="p", pch=19, cex=1.2,
main=paste("Simulated maximum t-copula (df=",df,") depth estimators"),
xlab="Real parameter", ylab="Parameter with maxim um depth")
for(i in 1:10){
segments(dep.summary[i,1],dep.summary[i,2]-dep.summary[i,3],
dep.summary[i,1],dep.summary[i,2]+dep.summary[i,3], lwd=2)
}
abline(0,1, lty=2)
library(VineCopula)
###### required for parallel computing
library(parallel)
library(doSNOW)
set.seed(006); N = 100
theta.range=seq(0,.99,.01)
dfs=c(25); mat=matrix(rep(0,6*length(dfs)), ncol=6)
for(i in 1:length(dfs)){
df = dfs[i]
## Simulates max depth copula estimators for all values in theta.range
loopfun = function(theta){
library(VineCopula)
maxdeps = rep(0,1000)
# Generate 1000 samples of size 100 each
for(i in 1:1000){
# Generate sample from t copula
U = BiCopSim(N, family=2, par=theta, par2=df)
u = U[,1]; v = U[,2]
est = BiCopEst(u, v, family=2, method='mle')
interval = c(0,.99)
# interval search algorithm
iterating=TRUE; iter=1; maxit=10
while(iterating){
theta.list = seq(interval[1], interval[2], length.out=10)
dep.list = rep(0,10)
for(j in 1:10){
del.loglik = BiCopDeriv(u,v,family=2,par=theta.list[j], par2=df, deriv="par") /
BiCopPDF(u,v,family=2,par=theta.list[j], par2=df)
dep.list[j] =(min(sum(del.loglik>0), sum(del.loglik<0)) + sum(del.loglik==0))/N
}
# stopping criteria
maxdep = max(na.omit(dep.list))
if(maxdep==0.5 || iter==maxit) iterating = FALSE
# otherwise determine new interval
else{
max.index = which(dep.list==maxdep)
if(length(max.index)==1){
lm = ifelse(max.index==1, interval[1], theta.list[max.index-1])
rm = ifelse(max.index==10, interval[2], theta.list[max.index+1])
}
else{
m1 = min(max.index); m2 = max(max.index)
lm = ifelse(m1==1, interval[1], theta.list[m1-1])
rm = ifelse(m2==10, interval[2], theta.list[m2+1])
}
interval = c(lm,rm)
iter=iter+1
}
}
maxdeps[i] = theta.list[which.max(dep.list)]
}
return(list(theta, mean(maxdeps), sd(maxdeps)))
}
dep.summary = matrix(rep(0,3*length(theta.range)), ncol=3)
cl <- makeCluster(detectCores())
registerDoSNOW(cl)
system.time(dep.summary <- foreach(theta = theta.range) %dopar% loopfun(theta))
dep.summary = matrix(unlist(dep.summary), ncol=3, byrow=T)
stopCluster(cl)
# plot(dep.summary[,2]~theta.range, xlim=c(0,1),ylim=c(0,1), type="p", pch=19, cex=1.2,
#      main=paste("Simulated maximum t-copula (df=",df,") depth estimators"),
#      xlab="Real parameter", ylab="Parameter with maxim um depth")
# for(i in 1:10){
#   segments(dep.summary[i,1],dep.summary[i,2]-dep.summary[i,3],
#            dep.summary[i,1],dep.summary[i,2]+dep.summary[i,3], lwd=2)
# }
# abline(0,1, lty=2)
# Fit cubic regression model
th = dep.summary[,1]; bth = dep.summary[,2]
summary(m <- lm(th ~ bth+I(bth^2)+I(bth^3)))
mat[i,] = c(df, m$coef, dep.summary[1,2])
}
mat
paste("Year",2002)
for(i i 1:10){paste("Year", i)}
for(i in 1:10){paste("Year", i)}
c = for(i i 1:10){paste("Year", i)}
c = for(i in 1:10){paste("Year", i)}
c
c=rep(0,10)
for(i in 1:10){ c[i] = concatenate("Year", as.character(i))}
for(i in 1:10){ c[i] = paste("Year", as.character(i))}
c
?paste
for(i in 1:10){ c[i] = paste("Year", as.character(i), sep="")}
c
library(Sleuth3)
head(case1202)
m.full = lm(Bsal ~ Senior+Age+Educ+Exper, data=case1202)
summary(m.full)
m.full = lm(log(Bsal) ~ Senior+Age+Educ+Exper, data=case1202)
summary(m.full)
step(m.full, direction="forward")
step(m.full, direction="backward")
?step
step(m.full, direction="backward", trace=F)
step(m0, scope=~Senior+Age+Educ+Exper, direction="forward")
m0 = lm(log(Bsal) ~ 1, data=case1202)
step(m0, scope=~Senior+Age+Educ+Exper, direction="forward")
step(m0, scope = ~Senior+Age+Educ+Exper, direction="forward", trace=F)
m.back = step(m.full, direction="backward", trace=F)
summary(m.back)
m.for = step(m0, scope = ~Senior+Age+Educ+Exper, direction="forward", trace=F)
summary(m.for)
m2.full = lm(log(Bsal) ~ (Senior+Age+Educ+Exper)^2, data=case1202)
summary(m2.full)
step(m2.full, direction="backward", trace=F)
m2.back = step(m2.full, direction="backward", trace=F); summary(m2.back)
m2.for = step(m0, scope = ~(Senior+Age+Educ+Exper)^2, direction="forward")
m2.for = step(m0, scope = ~(Senior+Age+Educ+Exper)^2, direction="forward", trace=F)
summary(m2.for)
summary(m2.back)
AIC(m2.back)
AIC(m2.for)
BreastTissue <- read.csv("C:/Study/UMN files/3022/BreastTissue.csv")
View(BreastTissue)
pairs(BreastTissue[, 3:11])
pairs(BreastTissue[, 3:11]); X = pobs(BreastTissue[, 3:11])
X = pobs(BreastTissue[, 3:11]); colnames(x) = colnames(BreastTissue)[3:11]
?pobs
library(copula)
X = pobs(BreastTissue[, 3:11]); colnames(x) = colnames(BreastTissue)[3:11]
X = pobs(BreastTissue[, 3:11]); colnames(X) = colnames(BreastTissue)[3:11]
View(X)
pairs(X)
names(X)
colnames(X)
m3.full = lm(P~I0+PA500+HFS+DA+Area+A.dA+Max.IP+DR, data=X)
m3.full = lm(P~I0+PA500+HFS+DA+Area+A.dA+Max.IP+DR, data=data.frame(X))
m3.full = lm(P~I0+PA500+HFS+DA+Area+A.DA+Max.IP+DR, data=data.frame(X))
summary(m3.full)
step(m3.full, direction="backward", trace=F)
step(m30, scope=~I0+PA500+HFS+DA+Area+A.DA+Max.IP+DR,
direction="forward", trace=F)
m30 = lm(P~1, data=data.frame(X))
step(m30, scope=~I0+PA500+HFS+DA+Area+A.DA+Max.IP+DR,
direction="forward", trace=F)
step(m3.full, direction="backward", trace=F)
View(case1202\)
View(case1202)
m4.full = lm(log(Bsal) ~ Senior+Age+Educ+Exper+Sex, data=case1202)
summary(m4.full)
m4.back = step(m4.full, direction="backward")
step(m0, scope = ~Senior+Age+Educ+Exper, direction="forward")
step(m.full, direction="backward", trace=F)
m4.back = step(m4.full, direction="backward", trace=F)
step(m4.full, direction="backward", trace=F)
install.packages("Rcmdr")
library(Rcmdr)
?stepwise
stepwise(m.full, direction="backward", criterion="BIC")
step(m.full, direction="backward", k=log(n))
n=length(case1202$Bsal)
step(m.full, direction="backward", k=log(n))
stepwise(m.full, direction="backward", criterion="BIC")
library(Sleuth3)
head(case1202)
pairs(case1202[,c(1,4,5,6,7)])
m.full = lm(log(Bsal) ~ Senior+Age+Educ+Exper, data=case1202)
summary(m.full)
step(m.full, direction="backward")
summary(m.full)
step(m.full, direction="backward", trace=F)
m0 = lm(log(Bsal) ~ 1, data=case1202)
step(m0, scope = ~Senior+Age+Educ+Exper, direction="forward")
step(m0, scope = ~Senior+Age+Educ+Exper, direction="forward", trace=F)
step(m.full, direction="backward", trace=F)
m4.full = lm(log(Bsal) ~ Senior+Age+Educ+Exper+Sex, data=case1202)
summary(m4.full)
m.full = lm(log(Bsal) ~ Senior+Age+Educ+Exper, data=case1202)
summary(m.full)
step(m4.full, direction="backward", trace=F)
step(m.full, direction="backward", trace=F)
View(case1202)
summary(m4.full)
step(m0, scope = ~Senior+Age+Educ+Exper+Sex, direction="forward", trace=F)
step(m4.full, direction="backward", trace=F)
m.back = step(m.full, direction="backward", trace=F)
summary(m.back)
m2.full = lm(log(Bsal) ~ (Senior+Age+Educ+Exper)^2, data=case1202)
summary(m2.full)
m2.back = step(m2.full, direction="backward", trace=F); summary(m2.back)
m2.for = step(m0, scope = ~(Senior+Age+Educ+Exper)^2, direction="forward", trace=F)
summary(m2.for)
m2.back
m2.for
AIC(m2.back)
AIC(m2.for)
BreastTissue <- read.csv("C:/Study/UMN files/3022/BreastTissue.csv")
pairs(BreastTissue[, 3:11])
library(copula)
X = pobs(BreastTissue[, 3:11]); colnames(X) = colnames(BreastTissue)[3:11]
BreastTissue <- read.csv("C:/Study/UMN files/3022/BreastTissue.csv")
pairs(BreastTissue[, 3:11])
library(copula)
X = pobs(BreastTissue[, 3:11]); colnames(X) = colnames(BreastTissue)[3:11]
pairs(X)
m3.full = lm(P ~ I0+PA500+HFS+DA+Area+A.DA+Max.IP+DR, data=data.frame(X))
summary(m3.full)
step(m3.full, direction="backward", trace=F)
m30 = lm(P~1, data=data.frame(X))
step(m30, scope=~I0+PA500+HFS+DA+Area+A.DA+Max.IP+DR,
direction="forward", trace=F)
cor(X[,4],X[,8])
cor(X[,4],X[,7])
cor(X[,8],X[,7])
step(m.full, direction="backward") # uses AIC
step(m.full, direction="backward", trace=F) # uses AIC
stepwise(m.full, direction="backward", criterion="BIC", trace=F)
library(Sleuth3)
head(case1202)
pairs(case1202[,c(1,4,5,6,7)])
m.full = lm(log(Bsal) ~ Senior+Age+Educ+Exper, data=case1202)
summary(m.full)
step(m.full, direction="backward")
summary(m.full)
step(m.full, direction="backward", trace=F)
m0 = lm(log(Bsal) ~ 1, data=case1202)
step(m0, scope = ~Senior+Age+Educ+Exper, direction="forward")
step(m.full, direction="backward", trace=F)
step(m0, scope = ~Senior+Age+Educ+Exper, direction="forward", trace=F)
m.back = step(m.full, direction="backward", trace=F); summary(m.back)
m4.full = lm(log(Bsal) ~ Senior+Age+Educ+Exper+Sex, data=case1202)
summary(m4.full)
step(m4.full, direction="backward", trace=F)
step(m0, scope = ~Senior+Age+Educ+Exper, direction="forward", trace=F)
step(m0, scope = ~Senior+Age+Educ+Exper+Sex, direction="forward", trace=F)
step(m4.full, direction="backward", trace=F)
m2.full = lm(log(Bsal) ~ (Senior+Age+Educ+Exper)^2, data=case1202)
summary(m2.full)
m2.back = step(m2.full, direction="backward", trace=F); summary(m2.back)
m2.for = step(m0, scope = ~(Senior+Age+Educ+Exper)^2, direction="forward", trace=F)
summary(m2.for)
m2.back
m2.for
AIC(m2.back)
AIC(m2.for)
BreastTissue <- read.csv("C:/Study/UMN files/3022/BreastTissue.csv")
pairs(BreastTissue[, 3:11])
library(copula)
X = pobs(BreastTissue[, 3:11]); colnames(X) = colnames(BreastTissue)[3:11]
pairs(X)
library(copula)
require(copula)
install.packages("lattice")
library(copula)
X = pobs(BreastTissue[, 3:11]); colnames(X) = colnames(BreastTissue)[3:11]
pairs(X)
m3.full = lm(P ~ I0+PA500+HFS+DA+Area+A.DA+Max.IP+DR, data=data.frame(X))
summary(m3.full)
step(m3.full, direction="backward", trace=F)
m30 = lm(P~1, data=data.frame(X))
step(m30, scope=~I0+PA500+HFS+DA+Area+A.DA+Max.IP+DR,
direction="forward", trace=F)
cor(X$Max.IP,X$DA)
x=data.frame(X)
X=data.frame(X)
cor(X$Max.IP,X$DA)
cor(X$Max.IP,X$DR)
library(Rcmdr)
stepwise(m.full, direction="backward", criterion="BIC", trace=F)
step(m.full, direction="backward", trace=F) # uses AIC
citation()
toBibtex(citation())
library(sleuth3)
library(Sleuth3)
head(ex2011)
boxplot(Failure~Temperature, data=ex2011)
boxplot(Temperature~Failure, data=ex2011)
plot(ex2011)
m.log = glm(Failure~Temperature, data=ex2011, family=binomial)
summary(m.log)
pnorm(-2.053, lower.tail=T)
pchisq(5.945, df=1, lower.tail=F)
qchisq(0.95, df=1)
View(ex2011)
exp(5.56)/(1+exp(5.56))
summary(ex2011)
library(Sleuth3)
head(ex2011)
boxplot(Temperature~Failure, data=ex2011)
plot(ex2011)
m.log = glm(Failure~Temperature, data=ex2011, family=binomial)
summary(m.log)
pnorm(-2.053, lower.tail=TRUE)
pnorm(-2.053)
pchisq(5.945, df=1, lower.tail=FALSE)
1-pchisq(5.945, df=1, lower.tail=TRUE)
qchisq(0,95, df=1)
qchisq(0.95, df=1)
View(ex2011)
qnorm(0.975)
qt(0.975, df=22)
CI = c(-0.1713-2.08*0.0834, -0.1713+2.08*0.0834)
CI
CI = c(-0.1713-qnorm(0.975)*0.0834, -0.1713+qnorm(0.975)*0.0834)
CI
exp(5.56)/(1+exp(5.56))
summary(ex2011)
library(Sleuth3)
head(ex2011)
boxplot(Temperature~Failure, data=ex2011)
plot(ex2011)
summary(m.log)
m.log = lgm(Failure~Temperature, data=ex2011, family=binomial)
m.log = glm(Failure~Temperature, data=ex2011, family=binomial)
summary(m.log)
pnorm(-2.053, lower.tail=TRUE)
pnorm(-2.053)
pchisq(5.945, df=1, lower.tail=FALSE)
qchisq(0.95, df=1)
qnorm(0.975)
qt(0,975, df=22)
qt(0.975, df=22)
CI.t = c(-.1713 - 2.07*0.083, -.1713 + 2.07*0.083)
CI.t
CI.t = c(-.1713 - 1.96*0.083, -.1713 + 1.96*0.083)
CI.t
exp(5.56)/(1+exp(5.56))
summary(ex2011)
library(MASS)
library(stats)
library(pracma)
setwd("C:/Study/UMN files/8932")
source("supSVD_functions.R")
## Apply on simulated data
set.seed(42914)
n = 1000; p = 10; q = 2; r = 3
Y = matrix(rbinom(2*n, size=1, prob=.5), ncol=2)
B = mvrnorm(n=q, mu=rep(0,r), Sigma=diag(r))
V = gramSchmidt(mvrnorm(n=p, mu=rep(0,r), Sigma=diag(r)))$Q
Sigma.f = diag(c(10,7,4)); sigma2 = 2
F = mvrnorm(n=n, mu=rep(0,r), Sigma=Sigma.f)
E = mvrnorm(n=n, mu=rep(0,p), Sigma=sigma2*diag(p))
X = Y%*%B%*%t(V) + F%*%t(V) + E
a=supSVD(X=X, Y=Y, r=3, quiet=0)
## Chemometrics data
data508 = read.csv("data508.csv", header=T)
X = logt(as.matrix(data508[-1,-c(1,309)]))
Y = as.matrix(data508[-1,309])
vartype = as.factor(as.matrix(data508[1,-c(1,309)]))
Xts = X[,vartype==1]
Xtc = X[,vartype==2]
supSVD.analyze(X=scale(Xts), Y=scale(Y), quiet=T)
supSVD.analyze(X=scale(Xtc), Y=scale(Y), quiet=T)
fun = function(a,b) return((256*a+252*b)/508)
fun(0.7656250,0.6428571)
supSVD.analyze(X=scale(Xts), Y=scale(Y), quiet=T)
supSVD.analyze(X=scale(cbind(Xts,Xtc)), Y=scale(Y), quiet=T)
fun(0.7539062,0.6230159 )
supSVD.analyze(X=scale(X), Y=scale(Y), quiet=T)
fix(fun)
supSVD.analyze(X=scale(X), Y=scale(Y), quiet=T)
fun(0.7773438, 0.6309524 )
source("supSVD_functions.R")
supSVD.analyze(X=scale(Xts), Y=scale(Y), quiet=T)
fun(0.6757812, 0.5238095 )
supSVD.analyze(X=scale(Xtc), Y=scale(Y), quiet=T)
fun(0.7812500, 0.6666667 )
supSVD.analyze(X=scale(cbind(Xts,Xtc)), Y=scale(Y), quiet=T)
fun(0.7890625, 0.6190476 )
supSVD.analyze(X=scale(X), Y=scale(Y), quiet=T)
fun(0.7890625, 0.6309524 )
